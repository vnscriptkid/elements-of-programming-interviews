// recursion with cache
export function fibonacciGood(x: number) {}

// loop with reusable vars
export function fibonacciBest(x: number) {}

// brute force O(n)
export function maxSubarraySum(arr: number[]) {}

// use dp
export function maxSubarraySumGood(arr: number[]) {}

// better dp (space O(1))
export function maxSubarraySumBest(arr: number[]) {}
